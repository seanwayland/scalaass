package cosc250.assignmentOne

import scala.annotation.tailrec

object AssignmentOne {

  /**
    *  This is a sequence that John Conway (famous for the game of life) offered a prize about at a symposium at Bell
    *  Labs a long time ago.
    *
    *  a(1) = 1
    *  a(2) = 1
    *  a(n) = a(a(n - 1)) + a(n - a(n - 1)), for n > 2
    *
    *  You can find more on the sequence here
    *  https://oeis.org/A004001
    *
    *  Note that this problem is "1-indexed" -- ie, we're only defining the sequence starting at 1 instead of 0
    *
    *  Your function should produce the sequence from 1 to n (inclusive)
    *
    *  For style marks, use some memoisation so that you don't keep recomputing the same values.
    *  (But you don't need to produce a tail recursive solution)
    */
  def conwaySequence(n:Int):Seq[Int] = {

    (0 to n - 1).foldLeft(Vector[Int]()) { (v, idx) =>
      if (idx <= 1) v :+ 1 else v :+ (v(v(idx - 1) - 1) + v(idx - v(idx - 1)))
    }
  }

  /**
    * Use foldLeft to sum the number of characters in a tree of strings
    */
  // source  http://oldfashionedsoftware.com/2009/07/30/lots-and-lots-of-foldleft-examples/
  def countOfTree(tree:scala.collection.immutable.TreeSet[String]):Int = tree.foldLeft(0)((sum, _) => sum + 1)

  /**
    * Let's implement a Scrabble scorer.
    * It should take into account the letters in the word *and* the squares the word sits on.
    *
    * I've created a sealed trait to model the different kinds of square. A "sealed trait" means that every class or
    * object that implements that trait is defined in the same program file. Knowing that there aren't any other
    * potential Squares out there (eg, being added later by other programmers) means the compiler can do cleverer
    * exhaustiveness-checking for us.
    *
    */

  sealed trait Square
  case object OrdinarySquare extends Square
  case object DoubleLetterScore extends Square
  case object TripleLetterScore extends Square
  case object DoubleWordScore extends Square
  case object TripleWordScore extends Square

  /**
   * (You may assume all letters are uppercase)
   *
   * 1: A, E, I, O, U, L, N, S, T, R.
   * 2: D, G.
   * 3: B, C, M, P.
   * 4: F, H, V, W, Y.
   * 5: K
   * 8: J, X.
   * 10: Q, Z.
   *
   * You might find using "mystring".contains(char) useful to keep it short
   */
  def letterScore(char:Char):Int = {

    // create cases for each point
    val onePoints:String = {"AEIOULNSTR"}
    val twoPoints:String = {"DG"}
    val threePoints:String = {"BCMP"}
    val fourPoints:String = {"FHVWY"}
    val fivePoints:String = {"K"}
    val eightPoints:String = {"JX"}
    val tenPoints:String = {"QZ"}


    if (onePoints.contains(char)) {1}
    else if (twoPoints.contains(char)) {2}
    else if (threePoints.contains(char)) {3}
    else if (fourPoints.contains(char)) {4}
    else if (fivePoints.contains(char))  {5}
    else if (eightPoints.contains(char)) {8}
    else if (tenPoints.contains(char)) {10}
    else {0}






  }

  /**
    * This should work out what this letter scores, given the square it's on.
    * Don't forget - DoubleWordScores etc affect the word as a whole, not individual letters
    */
  def letterAndSquareScore(char:Char, sq:Square):Int = ???


  /**
    * Calculate the scrabble score for a word on a set of squares.
    *
    * Hint: the zip method on Seq will zip to sequences together into a sequence of tuples. For example,
    *
    * Seq(1, 2, 3).zip(Seq("A", "B", "C")) produces Seq((1, "A"), (2, "B"), (3, "C")).
    *
    * If the sequences are of lengths, it'll just zip as much as it can. For example,
    * Seq(1, 2).zip(Seq("A", "B", "C")) produces Seq((1, "A"), (2, "B")).
    *
    * Tuples can be accessed using _1 and _2
    * val tup = (1, 2)
    * tup._1 == 1
    *
    * or using destructuring assignmnet
    * val (x, y) = tup
    *
    */
  def scrabbleScore(word:String, squares:Seq[Square]):Int = ???


  /**
   * Let's solve the "8 queens" problem -- how to put eight queens on a chessboard without any of them attacking
   * each other.
   */

  /**
    * A position on the board. For our purposes, columns and rows are numbered from 1 to 8
    */
  case class Pos(x:Int, y:Int)

  /** Are two positions in the same row? */
  def sameRow(p1:Pos, p2:Pos):Boolean = ???

  /** Are two positions in the same column? */
  def sameCol(p1:Pos, p2:Pos):Boolean = ???

  /** Are two positions on the same diagonal? Remember, there are two diagonals to worry about. */
  def sameDiagonal(p1:Pos, p2:Pos):Boolean = ???

  /**
   * Now let's define a function to test whether queens in two positions are attacking each other.
   * Don't forget a queen cannot attack itself. ie, (4,4) is not attacking (4,4)
   */
  def attackingEachOther(p1:Pos, p2:Pos):Boolean = ???

  /**
    * Using your attackingEachOther method, write a function that looks through a sequence of positions and finds if
    * there are any queens attacking each other
    */
  def seqContainsAttack(queens:Seq[Pos]):Boolean = ???

  /**
    * This method should take a sequence of rows. To solve eight queens, all of the queens must be in different columns.
    * So, rather input the full positions for each queen, we can just take (in order) the row number for each column.
    * ie, Seq(1, 8, 2, 7) would mean there's a queen at (1,1) another at (2, 7), another at (3, 2), another at (4, 7).
    *
    * Use your seqContainsAttack function to work out whether a sequence in this format contains an attack. You might
    * find the "zipWithIndex" function helpful. This starts at zero, not one, which might or might not make a difference.
    */
  def seqContainsAttackI(queens:Seq[Int]):Boolean = ???
  /**
    * Now we're going to use another trick to make the whole computation very small. As well as the queens all being
    * in different columns, they're also all in different rows. So every solution is going to be a permutation of
    * Seq(1, 2, 3, 4, 5, 6, 7, 8). But we're going to need to filter the permutations to only the ones that work.
    *
    * Write your function to calculate all 92 solutions to the eight queens problem
    *
    * You might find the following useful:
    * - permutations will produce an Iterator across the permutations of a sequence
    * - filterNot will filter a Seq, Iterator, etc, to only those where a particular function returns false
    * - toSeq will turn a List, Iterator, etc, into a Seq (sequence)
    */
  def eightQueens:Seq[Seq[Int]] = ???


  /**
   * Given two strings of equal length, calculate the number of characters that are different in each string.
   *
   * eg, "BLAB" and "BLOB" are 1 character different. "RAM" and "MAR" are 2 characters different.
   */
  def numDiffChars(a:String, b:String):Int = ???

  /**
    * I'll give you this method -- it takes a sequence and returns a sequence of tuples, with each pair. eg,
    * seqToPairs(Seq(1, 2, 3)) would produce Seq((1, 2), (2, 3))
    */
  def seqToPairs[T](s:Seq[T]):Seq[(T,T)] = s zip s.tail

  /**
   * Given a sequence of strings, sum the character changes that would be needed to change each string to the next
   * eg:
   *
   * SUM
   * SAM  (1 change)
   * BAT  (2 changes)
   * total: 3 changes
   */
  def sumChanges(s:Seq[String]):Int = ???

  /**
    * Given a sequence of strings, reorder the strings so that sumChanges will be as small as possible.
    * A sequence and its reverse will have the same length.
    */
  def smallestChanges(strings:Seq[String]):Seq[String] = ???


  /**
   * Now lets make a little calculator
   * Again I've got you started by defining a sealed trait and a few case classes
   */
  sealed trait Expression {

    /** result should calculate the answer. You should implement it in the subclasses. */
    def result:Double

    /**
      * Implement foldLeft... If you've got it right, then count will work
      *
      * Normally, we define foldLeft on a list, but actually it can be generalised to data types such as trees.
      * Technically, it then gets called a "catamorphism", but let's just stick with foldLeft
      *
      * You might find it helpful to sketch a little expression tree, and then think about
      * - what you would do for leaf nodes
      *   hint: you can work that out from the types --- you have a function that takes a value, and a node containing a value
      * - what you would do for non-leaf nodes
      *   hint: just work it out for the three-node tree. And remember you are processing from left to right
      */
    def foldLeft[A](start:A)(f:(A, Expression) => A):A

    /** Traverses the nodes from left to right, counting them if they match a condition. */
    def count(f:Expression => Boolean) = foldLeft(0) {
      case (counted, expr) if f(expr) => counted + 1
      case (counted, _) => counted
    }
  }

  case class Number(i:Int) extends Expression {
    override def result = ???

    override def foldLeft[A](start:A)(f:(A, Expression) => A) = ???
  }
  case class Add(left:Expression, right:Expression) extends Expression {
    override def result = ???

    override def foldLeft[A](start:A)(f:(A, Expression) => A) = ???
  }
  case class Multiply(left:Expression, right:Expression) extends Expression {
    override def result = ???

    override def foldLeft[A](start:A)(f:(A, Expression) => A) = ???

  }
  case class Subtract(left:Expression, right:Expression) extends Expression {
    def result = ???

    def foldLeft[A](start:A)(f:(A, Expression) => A) = ???
  }

  /** Calculate the result of an expression */
  def calculate(ex:Expression) = ex.result

  /** Now implement a function that will count how many Multiply nodes there are in the calculation */
  def countMultiplications(ex:Expression):Int = ???


  /**
    * We started with John Conway -- let's finish with his most famous creation: Conway's Game of Life.
    * https://en.wikipedia.org/wiki/Conway's_Game_of_Life
    *
    * Suppose we have a grid of squares, say 20 by 20
    * And a square can be filled in (alive) or not filled in (dead).
    *
    * And at each "time step", we generate a new grid using the following rules:
    * Any live cell with fewer than two live neighbours dies, as if caused by underpopulation.
    * Any live cell with two or three live neighbours lives on to the next generation.
    * Any live cell with more than three live neighbours dies, as if by overpopulation.
    * Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.
    * (Each cell has eight neighbours)
    *
    * We're going to define the game using an immutable Map.
    * Here, I've used Scala's "type alias" syntax to say that a ConwayState is a map from a tuple of ints to a boolean
    *
    * The tuple is going to contain (x, y) coordinates, and the Boolean is going to contain the values.
    * If an element in the map is missing, assume it to be false (dead). You can use getOrElse for this. This also
    * has the advantage that we *can* ask about negative indices -- getOrElse((-1, -1), false) will be false
    *
    */
  type ConwayState = Map[(Int, Int), Boolean]

  /**
    * Blinkers have a habit of toggling -- to help you test your code, I've included their definition.
    * If you have a blinker1, and you move forward one tick in the game state, you should get blinker2.
    * See the wikipedia page for more on this.
    */
  val blinker1:ConwayState = Map(
    (2, 1) -> true, (2, 2) -> true, (2, 3) -> true
  )
  val blinker2:ConwayState = Map(
    (1, 2) -> true, (2, 2) -> true, (3, 2) -> true
  )

  /**
    * First, define a function that given a tuple and a ConwayState will count the number of live neighbours
    */
  def liveNeighbours(pos:(Int, Int), state:ConwayState):Int = ???

  /**
    * Next, define a function that determines whether a position should be alive or dead
    */
  def aliveOrDead(pos:(Int, Int), state:ConwayState):Boolean = ???

  /**
    * Next, define a function that will compute the next state of the game of life, for a given maximum X and Y
    */
  def nextConwayState(state:ConwayState, maxSize:(Int, Int) = (20, 20)):ConwayState = ???

}
